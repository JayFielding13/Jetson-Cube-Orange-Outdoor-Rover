# BerryGPS‑IMU Setup Summary for Raspberry Pi + Python

## 1. Hardware and Assembly
- BerryGPS‑IMU v4 module (GPS + IMU sensors) with 5×2 header soldered.
- Insert module on Raspberry Pi GPIO or connect via QWIIC.
- For external GPS antenna, mount via uFL connector and set antenna switch to "Ext" (internal = "Int").
- Ensure GPS super-cap ensures ephemeris retention (~4 hrs).
- To use IMU via SPI: solder jumpers JP9 and JP13 (SPI ADC/Gyro). Default is I2C.
- Access sensor buses:
  - I2C: 3.3 V pins
  - SPI: 3.3 V SPI pins and INT pins
- Jumper details for I2C sensor addresses:
  - Gyro/Accel: default 0x6A, close JP5 for 0x6B
  - Magnetometer: 0x1C, close JP12 for 0x1E
  - Pressure: 0x77, cut JP3 to change to 0x76
- GPS I2C address: 0x42

## 2. Software & Dependencies
- OS: Raspberry Pi OS, ensure updated.
- Enable I2C via `raspi-config` or add `dtparam=i2c_arm=on,i2c_arm_baudrate=400000` to `/boot/config.txt`.
- Enable SPI if using SPI interface.
- Install Python SMBus and development tools: `sudo apt install python3-smbus i2c-tools python3-pigpio gpsd gpsd-clients`.

## 3. GPS Setup (UART vs I2C)
- **UART (default)**:
  - Disable serial console via `raspi-config → Interface Options → Serial`, then reboot.
  - Use `/dev/serial0`, baud 9600.
  - Install and configure `gpsd`:
    - In `/etc/default/gpsd`, set `DEVICES="/dev/serial0"`
    - Install: `sudo apt install gpsd gpsd-clients`
    - Restart: `sudo systemctl restart gpsd.socket`
    - Test: `cgps` or `gpspipe -r`
- **I2C GPS (optional)**:
  - Solder jumpers JP10 & JP11.
  - Use provided Python script to read NMEA from GPS via I2C at address 0x42:
    ```python
    import time, smbus
    BUS = smbus.SMBus(1)
    address = 0x42
    while True:
      # read bytes until newline
      ...
      print(nmea_line)
    ```
  - Bit‑bang alternative via `pigpio` if I2C stretch bug occurs.
  - Redirect output to virtual FIFO `/tmp/gps`, point GPSD to that FIFO.

## 4. GPS Data Logging
- Use `gpspipe -r -o filename.nmea` to log NMEA at boot (e.g. via `/etc/rc.local` or systemd).
- Visualize with Google Maps or GPSVisualizer.

## 5. IMU (Accelerometer, Gyro, Mag)
- Clone and use OzzMaker’s BerryIMU Python library:


https://github.com/ozzmaker/BerryIMU

cd BerryIMU

sudo apt install build-essential python3-dev

- Example code enables sensor registers via I2C, reads raw data, converts to g/dps/µT:
- Gyro+Accel address 0x6A (or 0x6B if jumper)
- Magnetometer at 0x1C (or 0x1E).
- Pressure sensor at 0x77.
- Register enabling per BerryIMU guide: control registers on LSM6DSL, LIS3MDL.
- Sample code in `gyro_accelerometer_tutorial01_angles`:
- Read raw registers, convert:
  - `rate_gyr = raw * G_GAIN (e.g., 0.07 for ±2000 dps)`
  - `acc_angle = atan2(...)`
- Combine through complementary filter or Kalman; use full BerryIMU lib or RTIMULib2.

## 6. Sensor Fusion & Navigation
- Sensor fusion code:
- OzzMaker BerryIMU library includes filters for orientation.
- For navigation (position), combine IMU dead‑reckoning with GPS using Kalman or RTQF.
- In ROS context, there's a RTIMULib2 fork with BerryGPS‑IMU support:
- Clone, build, run ROS node (see Inertial Platform README) :contentReference[oaicite:1]{index=1}.
- Note: magnetometer may be disabled due calibration inaccuracies :contentReference[oaicite:2]{index=2}.

## 7. Example Python Workflow Outline
1. Initialize I2C/SPI and SMBus.
2. Instantiate IMU reader (set registers).
3. Read sensor data at ~100 Hz loop:
 - Raw gyro, accel, mag, pressure.
 - Convert to dps, g, µT, Pa.
4. Run filter (complementary/Kalman).
5. Obtain GPS fix via `gpsd` or I2C reader.
6. Perform data fusion:
 - Use GPS position/speed to correct IMU drift.
 - Optional: use RTK or external filters.
7. Publish or write to JSON or ROS topics.

## 8. Files to Include for AI Understanding
- Register definitions from LSM6DSL & LIS3MDL.
- Python SMBus read/write functions.
- Conversion formulas (sensitivities).
- NMEA parsing logic.
- Fusion algorithm structure.

## 9. References – save for parsing:
- OzzMaker Quick‑Start: PCB, jumpers, I2C addresses, SPI info :contentReference[oaicite:3]{index=3}.
- BerryGPS UART setup guide :contentReference[oaicite:4]{index=4}.
- Accessing GPS via I2C scripts (+ pigpio method) :contentReference[oaicite:5]{index=5}.
- BerryIMU Python guide for raw sensor conversion :contentReference[oaicite:6]{index=6}.
- ROS inertial fusion example with RTIMULib2 :contentReference[oaicite:7]{index=7}.

---

That `.txt` contains all steps: hardware, I2C/SPI/UART setup, Python scripts, logging, sensor fusion. AI can parse functions, registers, addresses, formulas. Надеюсь, поможет!

If need actual ready‑made `.ini` or Python skeleton, just say.
::contentReference[oaicite:8]{index=8}
